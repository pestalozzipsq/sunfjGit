一、注解
1、常用注解
    @SpringBootApplication
    @Configuration
    @Bean
    @ConditionalOnMissingBean(ObjectMapper.class)
            当你的bean被注册之后，如果而注册相同类型的bean，就不会成功，它会保证你的bean只有一个，即你的实例只有一个。
    @Autowired/@Resource
    @Primary
        当有多个相同类型的bean时，使用@Primary来赋予bean更高的优先级
    @Qualifier(“beanName”)
        通过别名控制访问相同类型。
    @Value("${url.orderUrl}")
        获取配置文件中的属性
2、MVC流程注解
    @Service
    @Controller
    @Component
    @RestController
        返回的数据结构转换为 Json 格式。所以 @RestController 可以看作是 @Controller 和 @ResponseBody 的结合体
        不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用@RestController了
    @ResponseBody
        注解是将返回的数据结构转换为 Json
    @RequestBody
        @RequestBody 注解用于 POST 请求上，接收 json 实体参数
        实体参数可用于接收表单提交
    @RequestMapping  (@GetMapping\@PutMapping\@DeleteMapping\@PostMapping )
        可以用于类上，也可以用于方法上
        value 属性：指定请求的实际地址，value 可以省略不写
        method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET
        produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8”
    @PathVariable
        value:指定接收参数名
        用来获取 url 参数 GET ;请求携带一个参数 id 过来，我们将 id 作为参数接收
    @RequestParam
        从 request 里面获取参数值
        required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。
        defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。
        如果表单数据很多,我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。
        @PostMapping("/form2")
            public String testForm(User user) {
                System.out.println("获取到的username为：" + user.getUsername());
                System.out.println("获取到的password为：" + user.getPassword());
                return "success";
            }

3、测试相关注解
    @RunWith(SpringRunner.class)
        Test测试类要使用注入的类，比如@Autowired注入的类，有了@RunWith(SpringRunner.class)这些类才能实例化到spring容器中，自动注入才能生效。
    @SpringBootTest

    @Test
        测试方法


4、统一异常处理注解
    @ControllerAdvice
        适用于类，包含了 @Component 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 basePackages 属性，该属性是用来拦截哪个包中的异常信息
    @ExceptionHandler(NullPointerException.class)
        适用于方法，方法所在类需要被@ControllerAdvice注解，参数为拦截的异常
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
        设置Servlet返回的异常码
5、切面注解
    @Aspect
        用来描述一个切面类，定义切面类的时候需要打上这个注解
    @Pointcut
        用来定义一个切面（切入点），即上文中所关注的某件事情的入口。
        两个常用的表达式：
            一个是使用 execution()，
                以 execution(* com.itcodai.course09.controller..*.*(..))) 表达式为例，语法如下：
                execution() 为表达式主体
                第一个 * 号的位置：表示返回值类型，* 表示所有类型
                包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.itcodai.course09.controller 包、子包下所有类的方法
                第二个 * 号的位置：表示类名，* 表示所有类
                *(..) ：这个星号表示方法名，* 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数
            另一个是使用 annotation()。
                annotation() 方式是针对某个注解来定义切面，比如我们对具有@GetMapping注解的方法做切面，可以如下定义切面：
                @Pointcut("@annotation(org.springframework.web.bind.annotation.GetMapping)")
    @Before：
        在做某件事之前做的事。参数为加了切点的方法名@Before("pointCut()")
    @After：
        在做某件事之后做的事。同Before
    @AfterReturning(pointcut = "pointCut()", returning = "result")：
        在做某件事之后，对其返回值做增强处理。
    @AfterThrowing：
        在做某件事抛出异常时，处理。注解是当被切方法执行时抛出异常时，会进入 @AfterThrowing 注解的方法中执行
6、mybatis集成注解
    @Mapper
    @MapperScan("com.*.*.dao")
        注册mybatis dao类
    @Repository
    @Select("select * from .. where id=#{id}")
    @Insert
    @Update
    @Delete
        增删改查注解
    @Param("id")
        修饰dao方法参数，对应多个参数名称
    @Results({@Result(property = "username", column = "user_name")})
        明文设置entity与数据库对应字段,默认驼峰命名法，类似xml文件中ResultMap
7、事务
    @Transactional(Exception.class)
    使用于方法












二、配置
    默认核心配置文件名为 application，支持 application.properties、application.yml、application.yaml
    者同时存在时，优先级为：properties > yaml > yml
    直接或间接依赖 spring-cloud-context，此时才会读取 bootstrap.yml 文件和 application.yml 文件，这种情况下 bootstrap.yml 优先级高于其他核心配置文件。
    spring:
      profiles:
        active: local(@占位符@)
    java -jar hero-springboot-demo.jar --spring.profiles.active=test



三、版本控制
 <!--spring-boot 依赖版本-->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.12.RELEASE</version>
    </parent>


四、Swagger
    开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。
    依赖
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger2</artifactId>
        <version>2.2.2</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger-ui</artifactId>
        <version>2.2.2</version>
    </dependency>
    新建一个配置类，Swagger2 的配置类上除了添加必要的 @Configuration 注解外，还需要添加 @EnableSwagger2 注解。
    @Api 注解用于类上，表示标识这个类是 swagger 的资源。
    @ApiOperation 注解用于方法，表示一个 http 请求的操作。
    @ApiParam 注解用于参数上，用来标明参数信息。


五、集成Thymeleaf
    1、依赖导入
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>

    2、
    hymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。
    spring:
      thymeleaf:
        cache: false #关闭缓存
    templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面

    3、
    在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：<html xmlns:th="http://www.thymeleaf.org">
    使用模板引擎时，Controller 层就不能用 @RestController 注解
    thymeleaf 模板中，使用 th:object="${}" 来获取对象信息
    使用 th:value="*{属性名}"
    使用 th:value="${对象.属性名}"，对象指的是上面使用 th:object 获取的对象
    使用 th:value="${对象.get方法}"，对象指的是上面使用 th:object 获取的对象
    Thymeleaf 使用 th:each 进行遍历，${} 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 ${对象.属性名} 来获取 list 中对象的属性值，也可以使用 ${对象.get方法} 来获取，这点和上面处理对象信息是一样的，但是不能使用 *{属性名} 来获取对象中的属性，thymeleaf 模板获取不到

    4、常用th
    th:value	给属性赋值
    th:style	设置样式	th:style="'display:'+@{(${sitrue}?'none':'inline-block')} + ''"
    th:onclick	点击事件	th:onclick="'getInfo()'"
    th:if	条件判断
    th:href	超链接	Login />
    th:unless	条件判断和th:if相反	Login
    th:switch	配合th:case
    th:case	配合th:switch	administator
    th:src	地址引入
    th:action	表单提交的地址

    5、官方文档
    https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html


六、统一异常处理
    新建一个类
    GlobalExceptionHandler 全局异常处理类，然后加上 @ControllerAdvice 注解即可拦截项目中抛出的异常
    @ResponseBody 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。
    类中添加方法并添加下列注解，参数为对应异常
    @ExceptionHandler(NullPointerException.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)


七、AOP处理
    使用AOP，首先需要引入AOP的依赖。
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>


八、集成mybatis
    需要导入 mybatis-spring-boot-starter 和 mysql 的依赖
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    yml文件配置
        spring:
          datasource: # 数据库配置
            driver-class-name: com.mysql.cj.jdbc.Driver
            #mysql-connector-java8.0.0+版本需要增加参数&serverTimezone=Asia/Shanghai&useTimezone=true
            url: jdbc:mysql://localhost:3306/learning?useSSL=false&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10&serverTimezone=Asia/Shanghai&useTimezone=true
            username: root
            password: 123456
            hikari:
              maximum-pool-size: 10 # 最大连接池数
              max-lifetime: 1770000
        mybatis:
          # 指定别名设置的包为所有entity
          type-aliases-package: com.sunfj.entity
          configuration:
            map-underscore-to-camel-case: true # 驼峰命名规范
          mapper-locations: # mapper映射文件位置
            - classpath:mapper/*.xml

    1、通过xml配置文件形式使用
        在配置位置生成xml文件，在文件中配置数据库表查询信息及DAO类名称
        创建接口实现xml内业务，增加@Mapper注解或者启动类增加@MapperScan("*.dao")注册进mybatis

    2、注解使用
        @Select， @Insert， @Update， Delete
        使用@Param对应多个ID
        使用@Results({
            @Result(property = "username", column = "user_name")
        })对应字段,默认驼峰命名法，类似xml文件中ResultMap


九、事务控制
    1、依赖配置
        使用mybatis依赖，导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 @Transactional 注解进行事务的使用
    2、注解
        使用事务@Transactional 注解即可，适用于方法，生效范围为被注解的方法内发生RuntimeException和Error,rollbackFor属性可以指定异常类型
        常用@Transactional(Exception.class)
    3、失效场景
        非指定异常

        异常已经被try.catch处理，直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。

        @Transactional(rollbackFor = Exception.class)
            public synchronized void isertUser4(User user) {
                // 实际中的具体业务……
                userMapper.insertUser(user);
            }
        }
        可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。
        但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。
        从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。
        这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。


十、监听器
    /**
     * 使用ApplicationListener来初始化一些数据到application域中的监听器
     * @author shengni ni
     * @date 2018/07/05
     */
    @Component
    public class MyServletContextListener implements ApplicationListener<ContextRefreshedEvent> {

        @Override
        public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
            // 先获取到application上下文
            ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();
            // 获取对应的service
            UserService userService = applicationContext.getBean(UserService.class);
            User user = userService.getUser();
            // 获取application域对象，将查到的信息放到application域中
            ServletContext application = applicationContext.getBean(ServletContext.class);
            application.setAttribute("user", user);
        }
    }



    /**
     * 使用HttpSessionListener统计在线用户数的监听器
     * @author shengwu ni
     * @date 2018/07/05
     */
    @Component
    public class MyHttpSessionListener implements HttpSessionListener {

        private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class);

        /**
         * 记录在线的用户数量
         */
        public Integer count = 0;

        @Override
        public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) {
            logger.info("新用户上线了");
            count++;
            httpSessionEvent.getSession().getServletContext().setAttribute("count", count);
        }

        @Override
        public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
            logger.info("用户下线了");
            count--;
            httpSessionEvent.getSession().getServletContext().setAttribute("count", count);
        }
    }

    /**
     * 使用ServletRequestListener获取访问信息
     * @author shengwu ni
     * @date 2018/07/05
     */
    @Component
    public class MyServletRequestListener implements ServletRequestListener {

        private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class);

        @Override
        public void requestInitialized(ServletRequestEvent servletRequestEvent) {
            HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();
            logger.info("session id为：{}", request.getRequestedSessionId());
            logger.info("request url为：{}", request.getRequestURL());

            request.setAttribute("name", "测试");
        }

        @Override
        public void requestDestroyed(ServletRequestEvent servletRequestEvent) {

            logger.info("request end");
            HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();
            logger.info("request域中保存的name值为：{}", request.getAttribute("name"));

        }

    }



十一、拦截器
    1、定义拦截器
        只需要实现 HandlerInterceptor 接口，HandlerInterceptor 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： preHandle(……)、postHandle(……) 和 afterCompletion(……) 。

        preHandle(……) 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 preHandle(……) 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。
        postHandle(……) 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。
        afterCompletion(……) 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 preHandle(……) 被成功执行后并且返回 true 才会被执行。
    2、配置拦截器
       Spring Boot 2.0 之后，继承 WebMvcConfigurationSupport 类，重写addInterceptors 方法
    3、解决静态资源被拦截问题
        在 MyInterceptorConfig 配置类中重写 addInterceptors 方法外，还需要再重写一个方法：addResourceHandlers，将静态资源放开：
        /**
         * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
         * @param registry
         */
        @Override
        protected void addResourceHandlers(ResourceHandlerRegistry registry) {
            registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
            super.addResourceHandlers(registry);


       不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 addInterceptors 方法，将自定义的拦截器添加进去即可，如下：
       @Configuration
        public class MyInterceptorConfig implements WebMvcConfigurer {
            @Override
            public void addInterceptors(InterceptorRegistry registry) {
                // 实现WebMvcConfigurer不会导致静态资源被拦截
                registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");
            }

        继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；
        实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。


十二、集成Redis
    依赖导入
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    Redis 配置
    spring:
      #redis相关配置
      redis:
        database: 5
        # 配置redis的主机地址，需要修改成自己的
        host: 192.168.48.190
        port: 6379
        password: 123456
        timeout: 5000
        jedis:
          pool:
            # 连接池中的最大空闲连接，默认值也是8。
            max-idle: 500
            # 连接池中的最小空闲连接，默认值也是0。
            min-idle: 50
            # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)
            max-active: 1000
            # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException
            max-wait: 2000

    常用 api
    RedisTemplate 和 StringRedisTemplate
























